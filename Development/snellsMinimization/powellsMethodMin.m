function [CoMPos,EulAng,Eul] = powellsMethodMin(x0,CoMPos,rCentroidSide,rCentroidBotA,...
    rCentroidBotB,rCentroidSlant,uCentroidSide,...
    uCentroidBotA,uCentroidBotB,uCentroidSlant,...
    sideDotPosVec_cm,botADotPosVec_cm,botBDotPosVec_cm,lineSearch)

%gradientDescentMin Summary of this function goes here
%   Detailed explanation goes here

% x0 = [0 0 0]';
% x = [roll pitch yaw]

% J = objJ(x0,rCentroidSide,rCentroidBotA,rCentroidBotB,...
%     rCentroidSlant,uCentroidSide,uCentroidBotA,uCentroidBotB,uCentroidSlant,...
%     sideDotPosVec_cm,botADotPosVec_cm,botBDotPosVec_cm);

% minFcn = @(s,x) objJ(updateLaw(s,x,CoMPos,rCentroidSide,rCentroidBotA,rCentroidBotB,...
%     rCentroidSlant,uCentroidSide,uCentroidBotA,uCentroidBotB,uCentroidSlant,...
%     sideDotPosVec_cm,botADotPosVec_cm,botBDotPosVec_cm),CoMPos,rCentroidSide,rCentroidBotA,...
%     rCentroidBotB,rCentroidSlant,uCentroidSide,uCentroidBotA,uCentroidBotB,uCentroidSlant,...
%     sideDotPosVec_cm,botADotPosVec_cm,botBDotPosVec_cm);

dsgnVec = [];

x = x0;
for ii = 1:100
    RGB = calculateRotationMatrix(x(1),x(2),x(3));
    RBG = RGB';
    
    CoMPos = snellLeastSquaresPosition(rCentroidSide,rCentroidBotA,...
        rCentroidBotB,rCentroidSlant,uCentroidSide,...
        uCentroidBotA,uCentroidBotB,uCentroidSlant,RBG,...
        sideDotPosVec_cm,botADotPosVec_cm,botBDotPosVec_cm);

    x = powellsMethod(x,CoMPos,rCentroidSide,rCentroidBotA,rCentroidBotB,...
        rCentroidSlant,uCentroidSide,uCentroidBotA,uCentroidBotB,uCentroidSlant,...
        sideDotPosVec_cm,botADotPosVec_cm,botBDotPosVec_cm,'FunctionHandle',@objJ,...
        'LineSearchMethod',lineSearch,'DisplayOutput',false);
   
        dsgnVec(end+1,:) = [CoMPos(:)' x(:)'*180/pi];
    
    if ii>2 &&...
            all(abs(dsgnVec(end,1:3)-dsgnVec(end-1,1:3))<0.001) && all(abs(dsgnVec(end,4:6)-dsgnVec(end-1,4:6))*180/pi<0.1)
       break 
    end
end



end

